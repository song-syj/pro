#include <unistd.h>#include <signal.h>#include <sys/wait.h>#include <netinet/in.h>#include <arpa/inet.h>#include <stdio.h>#include <string.h>#include <stdlib.h>#include <errno.h>#include "sock_core.h" static int process_cmd(int fd,char *buff, int len);void sig_chld (int signo);static char start_flag = 0;static pid_t pid_data = 0;intmain(int argc, char *argv[]){	int listenfd, connfd;	int readlen;	pid_t pid;	struct sockaddr_in servaddr, cliaddr;	socklen_t clilen;	//	void (*sigfunc)(int);	char buff[MAXLINE];		listenfd = create_sock(AF_INET, SOCK_STREAM,IPPROTO_TCP);		servaddr.sin_family = AF_INET;	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);	servaddr.sin_port = htons(SERV_PORT);	bind_sock(listenfd, (SA *)&servaddr, sizeof(servaddr));			listen_sock(listenfd, LISTENQ);	//register a signal handler with signal SIGCHLD	if (signal(SIGCHLD, sig_chld) == SIG_ERR) {		perror("singal child");		exit (1);	}	for ( ; ; ) {		clilen = sizeof(cliaddr);		connfd = accept_sock(listenfd, (SA *)&cliaddr, &clilen);		if (errno == EINTR)			continue;				printf("connecting with client from IP address, %s....\n",			   inet_ntoa(cliaddr.sin_addr));		fflush(stdout);					if ((pid = fork()) < 0) {			perror("create a child process for receiving command");		} else if (pid == 0) {// a child process			close (listenfd);			while (1) {				memset(buff, 0, sizeof(buff));				if ( (readlen=readstring(connfd, buff, MAXLINE)) == 0) {					printf("client_cmd disconneted!");					break;				}										if (process_cmd(connfd, buff,readlen) == 0) 					break;			}			printf("exit success!\n");			return 0;		} else {			close(connfd);		}	}   	return 0;}voidsig_chld (int signo){	pid_t pid;	int stat;	while ((pid = waitpid(-1, &stat, WNOHANG)) > 0);	return;}/* *function : *       search the fisrt character that is not space *input: *       the string that need to be searched.it must be string *       that terminates with '\0' *return : *       a character's position that its content is not space * */static char *skipspace(char *s){	while(*s == ' ') s++;	return s;}staticvoid remove_newline (char *s, int len){	int i = 0;	while (i < len) {		if (*(s + i) == '\n') {			*(s + i) = '\0';		}		i++;	}}/* *funciton : *        split the cmd from clietn_cm and deal with it *input: *        cmd string and its length *return: three values 0, -1, 1; *        return -1 if the cmd is illegal; *        return 1 if the cmd is logal; *        return 0 if the cmd is "exit" *exception : *         some conditions that is not to be dealt with * */static intprocess_cmd(int fd,char *buff, int len){	char *param;//for arg1 in cmd	char *cmd;//for arg0 in cmd	char argnum;//the number of args in cmd	int data; //hold the arg that is interger	unsigned char i = 0;	pid_t pid;	char info[MAXLINE];//some information feedback to peer	remove_newline(buff, len);		if (strcmp(buff,"exit") == 0) {		if (start_flag == 1 && pid_data != 0) {			kill(pid_data, SIGKILL);		}		return 0;	}	/* split command and its parament */	i = 0;	cmd = skipspace(buff);	argnum = 1;	while (cmd[i] != 0) {		if (cmd[i] == ' ' && cmd[i+1] != 0 ) {			param = cmd + i +1;			cmd[i] = '\0';			argnum++;			break;		}		i++;	}	//deal with different cmd	if (strcmp(cmd, "start") == 0) {		if (start_flag == 0) {			sprintf(info,"server is starting!\n");			write(fd, info, strlen(info)+1);			if ( (pid =fork()) < 0) {				perror("fork child process for data transmission");				exit(1);			} else if (pid == 0) {//child process				struct sockaddr_in peeraddr;				socklen_t peelen;				peelen = sizeof(peeraddr);				//get the client IP address				if ( (i = getpeername(fd, (SA *)&peeraddr, &peelen) )< 0) {					sprintf(info, "%d, getpeername error\n", i);					write(fd, info, strlen(info)+1);					exit(1);				}				/* run the client for data transmission */ 				if (execl("./CLIENT_DATA", "./CLIENT_DATA", inet_ntoa(peeraddr.sin_addr), "sdata.dat", NULL) < 0) {					perror("start client_data");					sprintf(info, "execl error\n");					write(fd, info, strlen(info)+1);					exit(1);				}			} else {//parent processe				start_flag = 1;				pid_data = pid;			}		} else {// the server for command has been started before			sprintf(info, "server_cmd has been started!\n");			write(fd, info, strlen(info)+1);		}			}else if (strcmp(cmd, "write") == 0) {/* deal with "write command" */		if (argnum < 2) {			sprintf(info, "input a data after write\n");			write(fd, info, strlen(info)+1);		}else {			data = atoi(param);			sprintf(info, "write %d to register\n", data);			write(fd, info, strlen(info)+1);		}			}else if (strcmp(cmd,"reset") == 0) {	/* deal with "reset" command*/		//		killall();        if (start_flag == 1 && pid_data != 0) { /*  */			kill(pid_data, SIGKILL);		}		/* feedback information */		sprintf(info, "server resting\n");		write(fd, info, strlen(info)+1);		/* initate the data about client*/		start_flag = 0;		pid_data = 0;	}else {// a illegl command		sprintf(info, "command illegal!\n");		write(fd, info, strlen(info)+1);		return -1;	}		return 1;}